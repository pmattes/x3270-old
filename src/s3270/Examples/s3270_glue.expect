# Glue functions
proc x3270_cmd {cmd} {
	global verbose
	if {$verbose} {puts "$cmd"}
	send "$cmd\r"
	expect {
		-re "data: (.*)\r\n.*\r\nok\r\n$" { set r $expect_out(buffer) }
		"*ok\r\n" { return {} }
		"*error\r\n" { error "$cmd failed" }
		eof { error "s3270 died" }
	}
	# Convert to a list.
	set ret {}
	while {1} {
		if {! [regexp "data: (.*?)\r\n" $r dummy elt]} {break}
		set r [string range $r [expr [string length $elt]+7] end]
		if {[llength $ret] > 0} {
			set ret [linsert $ret end $elt]
		} {
			set ret $elt
		}
	}
	if {$verbose} {puts "ret llen [llength $ret]"}
	return $ret
}
proc Status {} {
	global verbose
	if {$verbose} {puts "(nothing)"}
	send "\r"
	expect {
		"*ok\r\n" { set r $expect_out(buffer) }
	}
	return [string range $r 0 [expr [string length $r]-7]]
}
proc Ascii {args} {
	set i 0
	set a ""
	while {$i < [llength $args]} {
		if {$i > 0} {
			set a "$a,[lindex $args $i]"
		} {
			set a [lindex $args $i]
		}
		incr i
	}
	return [x3270_cmd "Ascii($a)"]
}
proc Wait {args} {
	return [x3270_cmd "Wait($args)"]
}
proc Connect {host} {
	return [x3270_cmd "Connect($host)"]
}
proc String {text} {
	set a "\""
	set i 0
	while {$i < [string len $text]} {
		set c [string range $text $i $i]
		switch $c {
			"\n" { set a "$a\\n" }
			"\r" { set a "$a\\r" }
			" " { set a "$a\\ " }
			"\"" { set a "$a\\\"" }
			default { set a "$a$c" }
		}
		incr i
	}
	set a "$a\""
	#puts "String $a"
	return [x3270_cmd "String($a)"]
}
proc Enter {} {
	return [x3270_cmd "Enter"]
}
proc Clear {} {
	return [x3270_cmd "Clear"]
}
proc Snap {args} {
	set i 0
	set a ""
	while {$i < [llength $args]} {
		if {$i > 0} {
			set a "$a,[lindex $args $i]"
		} {
			set a [lindex $args $i]
		}
		incr i
	}
	return [x3270_cmd "Snap($a)"]
}
