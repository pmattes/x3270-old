The IND$FILE protocol, reverse-engineered.

Given the command:

    ind$file get test(test)

The file is 26 80-column records.

Once the keyboard is unlocked, the screen looks like:
    (protected,skip,nondisplay) field at (24,80) wrapped thru to (24,74)
    Contents: c3 81 81 81 40 00 ...
	      C  a  a  a  <b> NULL...
    (modified) field at (24,75) with the cursor at (24,76),
    Contents: NULLs

    Guess: 'C' seems to be a message.  'Caaa' may be 'opened OK'?

Sent Enter.
Got back:
    Contents: c1 82 c1 6b e5 5e (first line of file in EBCDIC)
	      A  b  A  ,  V  ;  T

    Guess: 'A' seems to be data.  'AbA,V;'... who knows?  What is the ';'
    (usually the 'code' is limited to 4 characters)?

Sent Enter.
Got back:
    Contents: c1 83 c3 83 d8 40 40 (continuation of file)
	      A  c  C  c  Q  <b><b>
    After end of file, NULLs.

    Guess: 'A' still seems to be data.  'AcCcQ'... who knows?

Sent Enter.
Got back:
    Contents: c1 84 e5 81 83 5c a9
	      A  d  V  a  c  *  z

    Guess: 'A' isn't quite data.  Is this EOF?  What's '*z'?

Sent Enter.
Got back:
    Contents: c3 85 81 89 e3
	      C  e  a  i  TRANS03   File transfer complete$

    Guess: 'C' is a message.  Is it significant that the second byte is
    ascending from 'a' to 'e'?  When does it wrap?  How does this
    signify that the transfer is over?

Sent Enter.
Got back:
    TSO screen.

Given the command:

    ind$file get foo(bar)  (bad)

Got back:
    Contents: c3 81 81 94
	      C  a  a  m  TRANS17  Missing or inc

Sent Enter.
Got back: TSO screen.
