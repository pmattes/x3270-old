Patch File #6 for x3270 3.0.2
Takes x3270 from version 3.0.2.5 to version 3.0.2.6

To apply, go into the directory where x3270 sources reside, and type:
    patch -p <x3270-3.0.2.fix06

Note that the "-p" switch is required.

1. Different gettimeofday syntax for Motorola.

*** globals.h.orig	Fri Sep  2 16:13:30 1994
--- globals.h	Fri Sep  2 16:13:30 1994
***************
*** 192,197 ****
--- 192,203 ----
  #define setlinebuf(s)	setvbuf(s, (char *)NULL, _IOLBF, BUFSIZ)
  #endif /*]*/
  
+ /* Motorola version of gettimeofday */
+ 
+ #if defined(MOTOROLA)
+ #define gettimeofday(tp,tz)	gettimeofday(tp)
+ #endif
+ 
  /* Global Functions */
  
  /* ansi.c */

2. Optional ability to limit MTU on outbound traffic.

*** telnet.c.orig	Fri Sep  2 16:15:27 1994
--- telnet.c	Fri Sep  2 16:15:27 1994
***************
*** 167,172 ****
--- 167,175 ----
  	unsigned short		port;
  	struct sockaddr_in	sin;
  	int			on = 1;
+ #if defined(OMTU) /*[*/
+ 	int			mtu = OMTU;
+ #endif /*]*/
  
  #	define close_fail	{ (void) close(sock); sock = -1; return -1; }
  
***************
*** 238,243 ****
--- 241,253 ----
  		popup_an_errno("setsockopt(SO_KEEPALIVE)", errno);
  		close_fail;
  	}
+ #if defined(OMTU) /*[*/
+ 	if (setsockopt(sock, SOL_SOCKET, SO_SNDBUF, (char *)&mtu, sizeof(mtu)))
+ 	{
+ 		popup_an_errno("setsockopt(SO_SNDBUF)", errno);
+ 		close_fail;
+ 	}
+ #endif /*]*/
  
  	/* set the socket to be non-delaying */
  	if (non_blocking(True) < 0)
***************
*** 710,723 ****
  	trace_netdata('>', buf, len);
  
  	while (len) {
  		if (pstate == NONE) {
! 			nw = write(sock, (char *) buf, len);
  			if (nw < 0) {
  				if (errno == EPIPE) {
  					x_disconnect();
  					return;
  				} else if (errno == EINTR) {
! 					continue;
  				} else {
  					popup_an_errno("write", errno);
  					x_disconnect();
--- 720,744 ----
  	trace_netdata('>', buf, len);
  
  	while (len) {
+ #if defined(OMTU) /*[*/
+ 		int n2w = len;
+ 		int pause = 0;
+ 
+ 		if (n2w > OMTU) {
+ 			n2w = OMTU;
+ 			pause = 1;
+ 		}
+ #else
+ #define n2w len
+ #endif
  		if (pstate == NONE) {
! 			nw = write(sock, (char *) buf, n2w);
  			if (nw < 0) {
  				if (errno == EPIPE) {
  					x_disconnect();
  					return;
  				} else if (errno == EINTR) {
! 					goto bot;
  				} else {
  					popup_an_errno("write", errno);
  					x_disconnect();
***************
*** 726,734 ****
  			}
  		} else
  			nw = len;
! 		ns_bsent += len;
  		len -= nw;
  		buf += nw;
  	}
  }
  
--- 747,761 ----
  			}
  		} else
  			nw = len;
! 		ns_bsent += nw;
  		len -= nw;
  		buf += nw;
+ 	    bot:
+ #if defined(OMTU) /*[*/
+ 		if (pause)
+ 			sleep(1);
+ #endif /*]*/
+ 		;
  	}
  }
  

3. Fix for wild behavior at the end of a field in blank-fill mode.

*** kybd.c.orig	Fri Sep  2 16:16:51 1994
--- kybd.c	Fri Sep  2 16:16:51 1994
***************
*** 249,274 ****
  		return False;
  	}
  	if (insert && screen_buf[baddr]) {
- 		int last_blank = -1;
  
! 		/* Find next null, next fa, or last blank */
  		end_baddr = baddr;
- 		if (screen_buf[end_baddr] == CG_space)
- 			last_blank = end_baddr;
  		do {
  			INC_BA(end_baddr);
- 			if (screen_buf[end_baddr] == CG_space)
- 				last_blank = end_baddr;
  			if (screen_buf[end_baddr] == CG_null
  			    ||  IS_FA(screen_buf[end_baddr]))
  				break;
  		} while (end_baddr != baddr);
  
! 		/* Pretend a trailing blank is a null, if desired. */
! 		if (toggled(BLANKFILL) && last_blank != -1) {
! 			INC_BA(last_blank);
! 			if (last_blank == end_baddr) {
  				DEC_BA(end_baddr);
  				ctlr_add(end_baddr, CG_null);
  			}
  		}
--- 249,279 ----
  		return False;
  	}
  	if (insert && screen_buf[baddr]) {
  
! 		/* Find next null or fa. */
  		end_baddr = baddr;
  		do {
  			INC_BA(end_baddr);
  			if (screen_buf[end_baddr] == CG_null
  			    ||  IS_FA(screen_buf[end_baddr]))
  				break;
  		} while (end_baddr != baddr);
  
! 		/*
! 		 * If the last character in the field is a space, perhaps
! 		 * convert it to a null.
! 		 */
! 		if (toggled(BLANKFILL) && IS_FA(screen_buf[end_baddr])) {
! 			int lastf = end_baddr;
! 
! 			DEC_BA(lastf);
! 			if (screen_buf[lastf] == CG_space) {
  				DEC_BA(end_baddr);
+ 
+ 				/* No shift required if only one byte. */
+ 				if (end_baddr == baddr)
+ 					goto shift_done;
+ 
  				ctlr_add(end_baddr, CG_null);
  			}
  		}
***************
*** 289,294 ****
--- 294,300 ----
  		}
  	}
  
+     shift_done:
  	/* Replace leading nulls with blanks, if desired. */
  	if (formatted && toggled(BLANKFILL)) {
  		register int	baddr2 = fa - screen_buf;

4. Explicit support for the NumLock key on Sun Type 5 keyboards.  Works
   only with Sun X servers.
   Fixes bug #316.

*** X3270.ad.orig	Mon Oct 10 09:22:31 1994
--- X3270.ad	Mon Oct 10 09:22:31 1994
***************
*** 512,518 ****
--- 512,536 ----
  ! Sun Type 5 keyboard map.  Not compatible with earlier Type 3 and Type 4
  ! keymaps, but does a better job of mapping intuitive functions to the
  ! existing key labels, and has fewer surprises.
+ !
+ ! The group of "Mod3" definitions at the beginning are for the numeric
+ ! keypad with the NumLock key down.  This only works with Sun X servers
+ ! (but not MIT X servers) but it is otherwise harmless.
  x3270.keymap.sun-k5: \
+ 	Mod3<Key>F25:		Key(/)\n\
+ 	Mod3<Key>F26:		Key(*)\n\
+ 	Mod3<Key>F24:		Key(-)\n\
+ 	Mod3<Key>F27:		Key(7)\n\
+ 	Mod3<Key>Up:		Key(8)\n\
+ 	Mod3<Key>F29:		Key(9)\n\
+ 	Mod3<Key>Left:		Key(4)\n\
+ 	Mod3<Key>F31:		Key(5)\n\
+ 	Mod3<Key>Right:		Key(6)\n\
+ 	Mod3<Key>R13:		Key(1)\n\
+ 	Mod3<Key>Down:		Key(2)\n\
+ 	Mod3<Key>F35:		Key(3)\n\
+ 	Mod3<Key>Insert:	Key(0)\n\
+ 	Mod3<Key>Delete:	Key(.)\n\
  	Shift<Key>0x1005ff10:	PF(23)\n\
  	Shift<Key>0x1005ff11:	PF(24)\n\
  	<Key>0x1005ff10:	PF(11)\n\
